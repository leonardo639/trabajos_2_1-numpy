# -*- coding: utf-8 -*-

#link colab: https://colab.research.google.com/drive/1mQXJnNaWCF9xPSCjAW0o-RP4B9SbvZpu?usp=sharing#scrollTo=eNwHgilLa0XD

"""Módulo 1.- Manipulación de Datos con Python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mQXJnNaWCF9xPSCjAW0o-RP4B9SbvZpu

<table width='99%'>
<tr>
<td bgcolor='#52008E'>

# **<font color="#FFFFFF"> ◉ Módulo 1.- Manipulación de Datos con Python</font>**

</td>
</tr>
</table>

<table width='99%'>
<tr>
<td bgcolor='#FFC901'>

## **<font color="#000000"> ◉ OBJETIVOS</font>**

</td>
</tr>
</table>

El objetivo del curso de Fundamentos de programación con Python y ETL, es proporcionar a los estudiantes los conocimientos y habilidades necesarios para comprender y aplicar los fundamentos de la programación en Python, así como también aprender a manipular y transformar datos utilizando librerías especializadas.

Al finalizar el curso, los estudiantes serán capaces de desarrollar programas en Python, realizar análisis básicos de datos, automatizar tareas repetitivas, extraer información de fuentes web y ejecutar flujos de trabajo de ETL para integrar y transformar datos de diferentes fuentes, sentando así las bases para su desarrollo en el ámbito de la programación y el análisis de datos.

<table width='99%'>
<tr>
<td bgcolor='#FFC901'>

## **<font color="#000000"> ◉ DIRIGIDO A:</font>**

</td>
</tr>
</table>

>* **Principiantes en programación**: Aquellos que deseen aprender programación desde cero y comenzar con Python como su primer lenguaje de programación.
>* **Estudiantes universitarios**: Estudiantes de carreras relacionadas con ciencias de la computación, ingeniería, matemáticas o disciplinas relacionadas, que deseen complementar su formación académica con habilidades en programación y análisis de datos.
>* **Profesionales en desarrollo de software**: Desarrolladores de software que deseen ampliar sus habilidades y aprender Python como un lenguaje adicional para el desarrollo de aplicaciones.
>* **Analistas de datos**: Profesionales que trabajan con datos y desean utilizar Python como una herramienta para manipular, analizar y visualizar datos.
>* **Científicos de datos**: Aquellos que deseen utilizar Python como parte de su flujo de trabajo para realizar análisis de datos y modelado estadístico.
>* **Profesionales en áreas relacionadas con ETL**: Personas que trabajan en el ámbito del procesamiento de datos, extracción y transformación de datos, y deseen utilizar Python como una herramienta para automatizar y optimizar flujos de trabajo de ETL.

<table width='99%'>
<tr>
<td bgcolor='#FFC901'>

## **<font color="#000000"> ◉ ¿Qué son las librerías de Python?</font>**

</td>
</tr>
</table>

Una biblioteca (o librería) es un conjunto de módulos, funciones y objetos predefinidos que se utilizan para extender las capacidades del lenguaje y facilitar tareas específicas. Las bibliotecas de Python son colecciones de código reutilizable que han sido desarrolladas por la comunidad de Python para abordar una amplia variedad de problemas y necesidades.

Las bibliotecas de Python se distribuyen como paquetes que contienen archivos con código fuente, documentación y recursos adicionales. Estos paquetes pueden ser instalados en un entorno de desarrollo de Python utilizando administradores de paquetes como **pip**, con lo que se hace posible acceder a las funcionalidades proporcionadas por la biblioteca y utilizarlas en tus propios programas.

<table width='99%'>
<tr>
<td bgcolor='#FFC901'>

## **<font color="#000000"> ◉ Algunas líbrerías a utilizar</font>**

</td>
</tr>
</table>

>* **NumPy**: Proporciona un potente soporte para cálculos numéricos y científicos, incluyendo matrices multidimensionales, operaciones matemáticas avanzadas y herramientas para trabajar con datos.
>* **Pandas**: Ofrece estructuras de datos y herramientas de análisis de datos fáciles de usar, como DataFrames, para manipular, limpiar y analizar datos de forma eficiente.
>* **Matplotlib**: Permite crear visualizaciones y gráficos en 2D de alta calidad para explorar y comunicar datos de manera efectiva.
>* **Scikit-learn**: Es una biblioteca de aprendizaje automático (machine learning) que proporciona una amplia gama de algoritmos y herramientas para tareas de clasificación, regresión, agrupamiento y más.
>* **TensorFlow y PyTorch**: Son bibliotecas populares de aprendizaje automático y redes neuronales que permiten desarrollar modelos de aprendizaje profundo y realizar tareas de procesamiento de datos a gran escala.

<table width='99%'>
<tr>
<td bgcolor='#FFC901'>

## **<font color="#000000"> ◉ Ventajas</font>**

</td>
</tr>
</table>

- **Eficiencia:** \
Librerías como Numpy y Pandas, proporcionan herramientas para la manipulación y análisis de grandes conjuntos de datos de manera eficiente.\
Esto permite trabajar con grandes cantidades de datos en un tiempo razonable.

- **Visualización de datos:** \
Librerías como Matplotlib permiten crear gráficos y visualizaciones personalizadas de los datos.\
Esto puede ayudar a comprender mejor los patrones y las relaciones entre diferentes variables.

- **Simulación y modelado:** \
Librerías como SciPy, proporcionan herramientas para el modelado y la simulación numérica de fenómenos complejos.\
Esto puede ayudar a realizar análisis predictivos y explorar diferentes escenarios de manera más efectiva.

- **Estándares y compatibilidad:** \
Python es un lenguaje de programación popular y bien establecido, y muchas de sus librerías se han convertido en estándares de facto en la industria.\
Esto significa que hay una gran cantidad de recursos, tutoriales y ejemplos disponibles para aprender y aplicar estas bibliotecas.

- **Personalización:** \
Las librerías son altamente personalizables y permiten ajustar y modificar las funciones y herramientas para satisfacer sus necesidades específicas.

<table width='99%'>
<tr>
<td bgcolor='#FFC901'>

## **<font color="#000000"> ◉ Numpy</font>**

</td>
</tr>
</table>

**NumPy (Numerical Python)** es una biblioteca fundamental de Python utilizada para realizar cálculos numéricos y científicos en el lenguaje de programación Python. Proporciona una estructura de datos eficiente y de alto rendimiento llamada "ndarray" (arreglo multidimensional) que permite almacenar y manipular grandes conjuntos de datos de manera eficiente.

<table border=1 width='99%'>
<tr>
<td bgcolor='#009CDE'>


### **<font color="#FFFFFF"> ◉ Características</font>**

</td>
</tr>
</table>

>* **Arreglos multidimensionales**: NumPy introduce el objeto ndarray, que es un arreglo multidimensional homogéneo y eficiente en el uso de memoria. Estos arreglos pueden tener un número arbitrario de dimensiones y contener elementos de un solo tipo de datos, lo que permite realizar operaciones vectorizadas y eficientes en grandes volúmenes de datos.
>* **Funciones matemáticas**: NumPy proporciona una amplia gama de funciones matemáticas y operaciones aritméticas que se pueden aplicar directamente a los arreglos. Esto incluye operaciones básicas como suma, resta, multiplicación y división, así como funciones más avanzadas como exponenciación, trigonometría, logaritmos, entre otras.
>* **Operaciones de matriz**: NumPy ofrece funciones y métodos para realizar operaciones de álgebra lineal, como multiplicación de matrices, inversión de matrices, resolución de sistemas de ecuaciones lineales, descomposiciones, valores propios y más. Estas operaciones son esenciales en muchas áreas, como la ciencia de datos, la física, la ingeniería y la investigación académica.
>* **Generación de números aleatorios**: NumPy incluye un generador de números aleatorios que permite crear secuencias de números aleatorios con diferentes distribuciones y propiedades estadísticas. Esto es útil para experimentos, simulaciones y aplicaciones que requieren aleatoriedad controlada.
>* **Integración con otras bibliotecas**: NumPy se integra estrechamente con otras bibliotecas científicas y de análisis de datos en Python, como SciPy, pandas y Matplotlib. Estas bibliotecas aprovechan las capacidades de NumPy y proporcionan funcionalidades adicionales para realizar análisis estadísticos, visualizaciones, optimización, procesamiento de señales y más.

<table border=1 width='99%'>
<tr>
<td bgcolor='#009CDE'>


### **<font color="#FFFFFF"> ◉ Instalación</font>**

</td>
</tr>
</table>

```
# En Visual Studio Code
pip install numpy

# En Colab
!pip install numpy
```
"""

import numpy as np

"""<table border=1 width='99%'>
<tr>
<td bgcolor='#009CDE'>

### **<font color="#FFFFFF"> ◉ Vectores</font>**

</td>
</tr>
</table>

Usaremos la función `array` para crear un vector:
"""

import numpy as np
vector = np.array([1, 2, 3, 4, 5])
print(vector)
print(type(vector))

"""Este **vector** contiene el mismo tipo de información en cada posición. Lo verificamos usando el atributo `dtype`:"""

import numpy as np
vector = np.array([1, 2, 3, 4, 5])
vector.dtype

"""Para transformar los valores del vector de **integer** a **float**, usaremos la función `astype`:"""

import numpy as np
vector = np.array([1, 2, 3, 4, 5])
print(vector.dtype)
v = vector.astype(float)
print(v)
print(v.dtype)

"""De manera similar a una lista o tupla, podemos seleccionar partes de un arreglo haciendo **slicing**:"""

import numpy as np
vector = np.array([1, 2, 3, 4, 5])
# Primer elemento
print(vector[0])

import numpy as np
#                  0  1  2  3  4
vector = np.array([1, 2, 3, 4, 5])
# Del tercer al quinto elemento
print(vector[2:5])

"""También podemos reemplazar valores dentro del vector:"""

import numpy as np
#                  -5 -4 -3 -2 -1
vector = np.array([1, 2, 3, 4, 5])
print(vector)
vector[-1] = 10
print(vector)

import numpy as np
vector = np.array([1, 2, 3, 4, 5])
print('Vector: ', vector)
##################
copia = vector
##################
print('Copia: ', copia)
copia[2] = 30
print('Vector: ', vector)
print('Copia: ', copia)

"""Podemos crear una copia del arreglo usando el método `copy`:"""

import numpy as np
vector = np.array([1, 2, 3, 4, 5])
print('Vector: ', vector)
copia = vector.copy()
print('Copia: ', copia)
copia[2] = 30
print('Vector: ', vector)
print('Copia: ', copia)

"""Podemos ordenar los elementos en un arreglo en forma ascendente con `sort`:"""

vector = np.array([5, 2, 3, 7, 1, 6])
ordenado = np.sort(vector)
print(vector)
print(ordenado)

"""En forma descendente:"""

vector = np.array([5, 2, 3, 7, 1, 6])
descendente = np.sort(vector)[::-1]
print(vector)
print(descendente)

"""<table border=1 width='99%'>
<tr>
<td bgcolor='#009CDE'>

### **<font color="#FFFFFF"> ◉ Matrices</font>**

</td>
</tr>
</table>

Usaremos la función `array` y una **lista de listas** para crear una matriz:
"""

matriz = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])
print(matriz)

"""Para obtener el número de dimensiones (Filas y Columnas), usaremos el atributo `ndim`:

"""

matriz = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])
print(matriz.ndim)

"""Para obtener el número de elementos en un arreglo, usaremos el atributo `size`:"""

matriz = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])
print(matriz.size)

"""Para obtener la forma de un arreglo, usaremos el atributo `shape`:"""

matriz = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])
print(matriz)
tupla = matriz.shape
print(type(tupla), ':', tupla)
filas, columnas = tupla
print('La matriz tiene', filas, 'filas y', columnas, 'columnas.')

"""Para hacer **slicing** a una matriz, debemos señalar la posición de la fila y columna en el siguiente orden: `arreglo[fila, columna]`"""

matriz = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])
print(matriz)
# Mostrar el elemento de la primera fila y primera columna de la matriz
print(matriz[0, 0])

matriz = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])
# Mostrar la primera fila
print(matriz[0, :])

matriz = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])
# Mostrar a partir de la segunda fila
print(matriz[1:, :])

"""Podemos usar el método `reshape` para cambiar la forma del arreglo:"""

matriz = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])
print(matriz)
vector = matriz.reshape((1,12))
print(vector)

"""La transpuesta de una matriz se calcula usando el atributo `T`:"""

matriz = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])

transpuesta = matriz.T

print(transpuesta)

"""Para reordenar los elementos de una matriz en un solo vector, podemos utilizar la función `flatten`:"""

matriz = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])

print(matriz.flatten())

"""<table width='99%'>
<tr>
<td bgcolor='#81BC06'>

#### **<font color="#FFFFFF"> ◉ Agrupación de matrices</font>**

</td>
</tr>
</table>
"""

# Podemos agrupar las matrices horizontalmente con hstack
matriz_1 = np.array([[1, 2, 3], [4, 5, 6]])
matriz_2 = np.array([[7, 8, 9], [10, 11, 12]])

matriz = np.hstack([matriz_1, matriz_2])

print(matriz)

# Podemos agrupar las matrices vertical con vstack
matriz_1 = np.array([[1, 2, 3], [4, 5, 6]])
matriz_2 = np.array([[7, 8, 9], [10, 11, 12]])

matriz = np.vstack([matriz_1, matriz_2])

print(matriz)

# Podemos usar la función concatenate para agruparloes de acuerdo a un eje (0: Vertical, 1: Horizontal)
matriz_1 = np.array([[1, 2, 3], [4, 5, 6]])
matriz_2 = np.array([[7, 8, 9], [10, 11, 12]])

matriz = np.concatenate([matriz_1, matriz_2], axis=0)

print(matriz)

# Podemos usar la función concatenate para agruparloes de acuerdo a un eje (0: Vertical, 1: Horizontal)
matriz_1 = np.array([[1, 2, 3], [4, 5, 6]])
matriz_2 = np.array([[7, 8, 9], [10, 11, 12]])

matriz = np.concatenate([matriz_1, matriz_2], axis=1)

print(matriz)

"""<table width='99%'>
<tr>
<td bgcolor='#81BC06'>

#### **<font color="#FFFFFF"> ◉ Matriz cero o Matriz uno</font>**

</td>
</tr>
</table>
"""

matriz = np.zeros(shape=(3,3))
print(matriz)

matriz = np.ones(shape=(3,4))
print(matriz)

"""<table border=1 width='99%'>
<tr>
<td bgcolor='#009CDE'>

### **<font color="#FFFFFF"> ◉ ALGEBRA LÍNEAL</font>**

</td>
</tr>
</table>
"""

# Dos vectores:
vector1 = np.array([1, 2, 3, 4])
vector2 = np.array([5, 6, 7, 8])

# Suma de vectores
vector_suma = vector1 + vector2
print(vector_suma)

# diferencia de vectores
vector_diferencia = vector2 - vector1
print(vector_diferencia)

# Multiplicar vectores
vector = vector2 * vector1
print(vector)
print('Producto escalar:', sum(vector))

# Dividir vectores
vector = vector2 / vector1
print(vector)

# Producto escalar
vector = np.dot(vector1, vector2)
print(vector)

"""<table border=1 width='99%'>
<tr>
<td bgcolor='#009CDE'>

### **<font color="#FFFFFF"> ◉ Creación de vectores usando arreglo de valores booleanos - Máscaras o mask</font>**

</td>
</tr>
</table>
"""

vector = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
print(vector)

vector_1 = (vector >= 4)
print(vector_1)

"""<table width='99%'>
<tr>
<td bgcolor='#F35325'>

##### **<font color="#FFFFFF"> ◉ Uso de where</font>**

</td>
</tr>
</table>
"""

vector = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
# Reemplazamos los valores del vector mayores o iguales a cuatro por 1 y los menores por el valor 0.
vector_1 = np.where(vector >= 4, 1, 0)
print(vector_1)

"""<table width='99%'>
<tr>
<td bgcolor='#81BC06'>

#### **<font color="#FFFFFF"> ◉ Funciones básicas para los arreglos</font>**

</td>
</tr>
</table>
"""

vector = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
print('Suma:', vector.sum())
print('Máximo:', vector.max())
print('Mínimo:', vector.min())
print('Promedio:', vector.mean())
print('Varianza:', vector.var())
print('Desviación estándar:', vector.std())

"""<table width='99%'>
<tr>
<td bgcolor='#81BC06'>

#### **<font color="#FFFFFF"> ◉ Constantes</font>**

</td>
</tr>
</table>
"""

print('Valor infinito: ', np.inf)
print('Valor nulo o vacío: ', np.nan)
print('Número de Euler: ', np.e)
print('PI: ', np.pi)

"""<table width='99%'>
<tr>
<td bgcolor='#81BC06'>

#### **<font color="#FFFFFF"> ◉ Espacios líneales</font>**

</td>
</tr>
</table>
"""

print(np.arange(1, 10, 1))
print(np.linspace(1, 10, 10))
print(np.linspace(1, 10, 5))

"""<table width='99%'>
<tr>
<td bgcolor='#81BC06'>

#### **<font color="#FFFFFF"> ◉ Valores aleatorios</font>**

</td>
</tr>
</table>
"""

aleatorios = np.random.default_rng()
print(aleatorios.random())

"""<table width='99%'>
<tr>
<td bgcolor='#81BC06'>

#### **<font color="#FFFFFF"> ◉ Distribución uniforme</font>**

</td>
</tr>
</table>
"""

# Un número aleatorio de una distribución uniforme entre 0 y 5
aleatorios.uniform(0,5)

# Número aleatorio entre 1 y 6
aleatorios.integers(1,7)

"""<table width='99%'>
<tr>
<td bgcolor='#81BC06'>

#### **<font color="#FFFFFF"> ◉ Matriz de tamaño 2 x 2 compuesta de valores aleatorios de una distribución normal de media 0 y varianza 1</font>**

</td>
</tr>
</table>
"""

matriz_aleatorios = aleatorios.normal(size=(2,2))
print(matriz_aleatorios)

"""<table border=1 width='99%'>
<tr>
<td bgcolor='#009CDE'>

### **<font color="#FFFFFF"> ◉ Simulación de valores aleatorios</font>**

</td>
</tr>
</table>
"""

# Crear 100 números aleatorios que se aproximen a una recta: y = 3*x+1
import numpy as np
import matplotlib.pyplot as plt

aleatorios = np.random.default_rng()

x = aleatorios.normal(size=(10, 10))
y = 3 * x  + aleatorios.normal(size=(10, 10)) + 1

fig, ax = plt.subplots(figsize=(6,6))

# Diagrama de dispersión
ax.scatter(x, y)

plt.show()

"""<table width='99%'>
<tr>
<td bgcolor='#81BC06'>

#### **<font color="#FFFFFF"> ◉ Valores aleatorios</font>**

</td>
</tr>
</table>
"""